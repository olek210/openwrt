From 1f9ac7843b19d4b497e6a842eefb443e82197c19 Mon Sep 17 00:00:00 2001
From: Aleksander Jan Bajkowski <A.Bajkowski@stud.elka.pw.edu.pl>
Date: Sat, 21 Nov 2020 23:37:38 +0100
Subject: [PATCH] lantiq: gswip add debug

---
 drivers/net/ethernet/lantiq_xrx200.c | 24 ++++++++++++++++++++----
 net/dsa/slave.c                      |  6 +++++-
 net/dsa/tag_gswip.c                  |  2 ++
 3 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/lantiq_xrx200.c b/drivers/net/ethernet/lantiq_xrx200.c
index 51ed8a54d380..a18ef4a0d5ad 100644
--- a/drivers/net/ethernet/lantiq_xrx200.c
+++ b/drivers/net/ethernet/lantiq_xrx200.c
@@ -119,6 +119,7 @@ static int xrx200_open(struct net_device *net_dev)
 	napi_enable(&priv->chan_tx.napi);
 	ltq_dma_open(&priv->chan_tx.dma);
 	ltq_dma_enable_irq(&priv->chan_tx.dma);
+	netdev_warn(net_dev, "ltq_dma_enablw_irq\n");
 
 	napi_enable(&priv->chan_rx.napi);
 	ltq_dma_open(&priv->chan_rx.dma);
@@ -131,8 +132,10 @@ static int xrx200_open(struct net_device *net_dev)
 	usleep_range(20, 40);
 	xrx200_flush_dma(&priv->chan_rx);
 	ltq_dma_enable_irq(&priv->chan_rx.dma);
+	netdev_warn(net_dev, "ltq_dma_enablw_irq\n");
 
 	netif_wake_queue(net_dev);
+	netdev_err(net_dev, "netif_wake_queue\n");
 
 	return 0;
 }
@@ -142,6 +145,7 @@ static int xrx200_close(struct net_device *net_dev)
 	struct xrx200_priv *priv = netdev_priv(net_dev);
 
 	netif_stop_queue(net_dev);
+	netdev_warn(net_dev, "netif_stop_queue\n");
 
 	napi_disable(&priv->chan_rx.napi);
 	ltq_dma_close(&priv->chan_rx.dma);
@@ -230,8 +234,10 @@ static int xrx200_poll_rx(struct napi_struct *napi, int budget)
 	}
 
 	if (rx < budget) {
-		if (napi_complete_done(&ch->napi, rx))
+		if (napi_complete_done(&ch->napi, rx)) {
 			ltq_dma_enable_irq(&ch->dma);
+			pr_warn("ltq_dma_enablw_irq\n");
+		}
 	}
 
 	return rx;
@@ -270,12 +276,16 @@ static int xrx200_tx_housekeeping(struct napi_struct *napi, int budget)
 	netdev_completed_queue(ch->priv->net_dev, pkts, bytes);
 
 	netif_tx_unlock(net_dev);
-	if (netif_queue_stopped(net_dev))
+	if (netif_queue_stopped(net_dev)) {
 		netif_wake_queue(net_dev);
+		netdev_warn(net_dev, "netif_wake_queue\n");
+	}
 
 	if (pkts < budget) {
-		if (napi_complete_done(&ch->napi, pkts))
+		if (napi_complete_done(&ch->napi, pkts)) {
 			ltq_dma_enable_irq(&ch->dma);
+			netdev_warn(net_dev, "ltq_dma_enablw_irq\n");
+		}
 	}
 
 	return pkts;
@@ -291,6 +301,8 @@ static netdev_tx_t xrx200_start_xmit(struct sk_buff *skb,
 	dma_addr_t mapping;
 	int len;
 
+	netdev_info(net_dev, "xrx200_start_xmit\n");
+
 	skb->dev = net_dev;
 	if (skb_put_padto(skb, ETH_ZLEN)) {
 		net_dev->stats.tx_dropped++;
@@ -321,8 +333,10 @@ static netdev_tx_t xrx200_start_xmit(struct sk_buff *skb,
 		LTQ_DMA_TX_OFFSET(byte_offset) | (len & LTQ_DMA_SIZE_MASK);
 	ch->dma.desc++;
 	ch->dma.desc %= LTQ_DESC_NUM;
-	if (ch->dma.desc == ch->tx_free)
+	if (ch->dma.desc == ch->tx_free) {
 		netif_stop_queue(net_dev);
+		netdev_warn(net_dev, "netdev_stop_queue\n");
+	}
 
 	netdev_sent_queue(net_dev, len);
 
@@ -350,6 +364,7 @@ static irqreturn_t xrx200_dma_irq(int irq, void *ptr)
 	if (napi_schedule_prep(&ch->napi)) {
 		__napi_schedule(&ch->napi);
 		ltq_dma_disable_irq(&ch->dma);
+		pr_warn("ltq_dma_disable_irq\n");
 	}
 
 	ltq_dma_ack_irq(&ch->dma);
@@ -532,6 +547,7 @@ static int xrx200_remove(struct platform_device *pdev)
 
 	/* free stack related instances */
 	netif_stop_queue(net_dev);
+	netdev_warn(net_dev, "netdev_stop_queue\n");
 	netif_napi_del(&priv->chan_tx.napi);
 	netif_napi_del(&priv->chan_rx.napi);
 
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index 3bc5ca40c9fb..7844b0881d2b 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -532,6 +532,7 @@ static void dsa_skb_tx_timestamp(struct dsa_slave_priv *p,
 
 netdev_tx_t dsa_enqueue_skb(struct sk_buff *skb, struct net_device *dev)
 {
+	pr_info("dsa_enqueue_skb\n");
 	/* SKB for netpoll still need to be mangled with the protocol-specific
 	 * tag to be successfully transmitted
 	 */
@@ -542,7 +543,9 @@ netdev_tx_t dsa_enqueue_skb(struct sk_buff *skb, struct net_device *dev)
 	 * do not modify its EtherType
 	 */
 	skb->dev = dsa_slave_to_master(dev);
-	dev_queue_xmit(skb);
+	int ret = dev_queue_xmit(skb);
+	if (ret != NET_XMIT_SUCCESS)
+		pr_warn("dsa: packet could be not sent: ret=%d\n", ret);
 
 	return NETDEV_TX_OK;
 }
@@ -567,6 +570,7 @@ static netdev_tx_t dsa_slave_xmit(struct sk_buff *skb, struct net_device *dev)
 	 */
 	dsa_skb_tx_timestamp(p, skb);
 
+	pr_info("dsa_slave_xmit\n");
 	/* Transmit function may have to reallocate the original SKB,
 	 * in which case it must have freed it. Only free it here on error.
 	 */
diff --git a/net/dsa/tag_gswip.c b/net/dsa/tag_gswip.c
index 408d4af390a0..e8bd33ee1485 100644
--- a/net/dsa/tag_gswip.c
+++ b/net/dsa/tag_gswip.c
@@ -63,6 +63,7 @@ static struct sk_buff *gswip_tag_xmit(struct sk_buff *skb,
 	int err;
 	u8 *gswip_tag;
 
+	// pr_info("gswip_tag_xmit\n");
 	err = skb_cow_head(skb, GSWIP_TX_HEADER_LEN);
 	if (err)
 		return NULL;
@@ -86,6 +87,7 @@ static struct sk_buff *gswip_tag_rcv(struct sk_buff *skb,
 	int port;
 	u8 *gswip_tag;
 
+	pr_info("gswip_tag_rcv\n");
 	if (unlikely(!pskb_may_pull(skb, GSWIP_RX_HEADER_LEN)))
 		return NULL;
 
-- 
2.20.1

